---
title: 0.1 + 0.2 !== 0.3？
date: 2021-04-01
categories: 
 - 面试
tags:
 - js精度问题
sidebar: 'auto'
---


> 题目来源<https://jsgodroad.com/questions/detail?id=28>

*为什么 0.1 + 0.2 !== 0.3，请描述原因并手写解决该问题的函数。


1. 因为JS中number类型的数据采用IEEE 754标准，即采用64位二进制来存储数据，其中`符号位`占`1`位，`指数位`占`11`位，`尾数位`占`52`位（超出的部分自动进一舍零），当0.1和0.2在转换为二进制时会出现无限循环的数，

> 将小数转换为二进制的方法
> 对小数乘以2，取结果的整数部分，然后再用小数部分再乘以2，再取结果的整数部分，直到小数部分为0或者位数已够，最后把取出的整数部分按先后次数排序。

0.1转换成二进制的过程：
0.1 * 2 = 0.2  取整数位 0

0.2 * 2 = 0.4  取整数位 0

0.4 * 2 = 0.8  取整数位 0

0.8 * 2 = 1.6  取整数位 1

0.6 * 2 = 1.2  取整数位 1

0.2 * 2 = 0.4  取整数位 0

0.4 * 2 = 0.8  取整数位 0

0.8 * 2 = 1.6  取整数位 1

0.6 * 2 = 1.2  取整数位 1

...

按照上面的方法将0.1转为二进制为


0.1(10) => 0.0001100110011(0011无限循环)(2)

所以说进度丢失不是语言的问题，而是浮点数存储本身有问题。对于这种无线循环的二进制数IEEE754规定了一种表示方式。
<img :src="$withBase('/images/interview/v7/31601584-f65ed43e-b21f-11e7-8755-c99b48e5134c.png')" alt="IEEE数值表示方式" />


注意上述公式遵循科学计数法的规范，在十进制是为0 < M < 10，到二进制就是0 < M < 2。也就是说整数部分只能是1，所以可以被舍去，只保留后面的小数部分。如4.5转成二进制时100.1，用科学计数法表示是1.001 * 2^2，舍去1后`M = 001`。E是一个无符号整形，因为长度有11位，取值范围为0 - 2047.但科学计数法中的指数是可以是负数的（例如：1.0 * 2^-5），所以再减去一个中间数1023，[0. 1022]表示为负，[1024, 2047]表示为正。如4.5的指数`E = 1025`（2 + 1023），位数M为001。

<img :src="$withBase('/images/interview/v7/31601584-f65ed43e-b21f-11e7-8755-c99b48e5134d.png')" alt="IEEE数值表示方式" />

0.0001100110011(0011无限循环)科学计数法表示为`1.1001100110011... * 2 ^ -4`，`E = -4 + 1023 = 1019`，M舍去首位1，得到1001100110011...所以`0.1`被表示为`(-1)^0 * 2^-4 + 1023 * 1001100110011...，最终就是

<img :src="$withBase('/images/interview/v7/11111111.png')" alt="0.1" />

（最后几位的11010是因为11001最后一位是1所以进一就变成了11010）
转换成十进制后就是0.100000000000000005551115123126，因此就出现了浮点误差。

同理`0.2`被存储为(-1)^0 * 2 ^-3 + 1023 * 1001100110011...
<img :src="$withBase('/images/interview/v7/2222.png')" alt="0.2" />


那么在计算时0.1 + 0.2计算步骤为
> 0.00011001100110011001100110011001100110011001100110011010 + 
> 0.0011001100110011001100110011001100110011001100110011010 =
> 0.0100110011001100110011001100110011001100110011001100111
最后结果转成十进制就是`0.30000000000000004`

### 参考
* JavaScript 浮点数陷阱及解法 <https://github.com/camsong/blog/issues/9>
* 探寻 JavaScript 精度问题以及解决方案<https://juejin.cn/post/6844903687010123790>

2. 在对小数进行四则运算时可以先将小数转为整数在进行运算
```js
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length
  const num2Digits = (num1.toString().split('.')[1] || '').length
  const base = Math.pow(10, Math.max(num1Digits, num2Digits))
  return (num1 * base + num2 * base) / base
}
```


