---
title: HTTP与HTTPS
date: 2020-08-09
categories: 
 - 网络
tags:
 - HTTPS
sidebar: 'auto'
---

## HTTP与HTTPS

### HTTP与HTTPS的区别
* HTTP协议在传输数据是使用明文传输，HTTPS使用加密后的秘闻传输
* HTTP协议使用的端口号是80，HTTPS使用的是445端口
* HTTPS需要拿到CA的证书。
* HTTP是无状态的协议，HTTPS协议由HTTP + SSL(安全套接字)/TLS(安全传输层协议)组成，在TCP三次握手后HTTPS协议需要跟客户端建立一个可加密数据的连接。

### HTTPS解决的问题
* 窃听风险
* 篡改风险
* 中间人攻击

### 窃听风险
HTTP协议使用明文传输，所以在传输过程中如果被黑客截获那么数据就会失去保密性。
<img :src="$withBase('/images/net/v1/http.png')" alt="明文传输" />

当客户端和服务器使用HTTP协议进行通信时由于传输的是明文数据所以当黑客窃听两者的通信时就可以截获数据。

### 对称加密
避免窃听的方法就是要对传输的数据进行加密，而对称加密就是加密和解密所使用的的秘钥是一样的。
<img :src="$withBase('/images/net/v1/http1.png')" alt="对称加密" />

使用对称秘钥加密后在进行传输，这样只要黑客没有秘钥就无法查看数据的内容。但这有一个问题，如何保证秘钥的安全传输呢？

### 非对称加密
非对称加密就是有一个公钥和一个私钥，公钥是公开的，可以发给任何人，而私钥是只有自己知道不能泄露给他人。
使用私钥加密只有公钥能解开，而使用公钥加密只有私钥能解开。
<img :src="$withBase('/images/net/v1/http2.png')" alt="非对称加密" />

服务器将自己的公钥发给客户端，客户端使用公钥加密数据后再发送给服务器，这样只有私钥的服务器才能解密出真正的数据，而黑客只有服务器的公钥是无法解密数据的。但当服务器回复客户端时，使用自己的私钥加密，然后发送出去，期间可能会被黑客拦截到，这时因为黑客也有服务端的公钥，也是可以解密出服务器发给真正客户端的信息，要解决这个问题可以让客户端和服务器都使用非对称加密传输，即服务器生成一个私钥和一个公钥，将公钥发给客户端，客户端也生成一个自己的私钥和公钥，并将公钥发给服务器。
<img :src="$withBase('/images/net/v1/http3.png')" alt="非对称加密" />

此时客户端有自己的私钥，自己的公钥和服务器的公钥，服务器有自己的私钥，自己的公钥，客户端的公钥，黑客同时拥有客户端的公钥和服务器的公钥，当客户端要发送数据给服务器时，使用服务器给的公钥加密数据然后发送给服务器，由于黑客只有服务器的公钥，所以无法解密数据，服务器端收到客户端发来的数据使用自己的私钥将数据解密，然后服务器使用客户端的公钥加密要发送的数据，黑客没有客户端的私钥也无法窃取服务器发给客户端的数据，这样客户端和服务器的通信就能安全的传输数据了。


### 密钥交换
两种密钥交换方式：
* RSA密钥交换算法
* Diffie-Hellman算法

### RSA密钥交换
<img :src="$withBase('/images/net/v1/http4.png')" alt="非对称加密" />

* 服务器生成一个公钥和一个私钥
* 客户端请求服务器首先得到服务器的公钥
* 客户端生成一个随机字符串作为对称加密的秘钥
* 黑客截获客户端发送的信息，但是没有服务器的私钥无法破解信息
* 使用服务器的公钥将字符串加密并发送给服务器
* 黑客截获服务器发送的信息，但是没有对称加密的秘钥无法破解信息
* 服务器使用自己的私钥解密，那到随机字符串
* 服务器将数据使用随机字符串做对称加密，加密完成后发送给客户端

### DH算法
<img :src="$withBase('/images/net/v1/DH.png')" alt="非对称加密" />

* 客户端产生一个数字传送给服务端(此时客户端、黑客、服务端都有这个数字)
* 服务端产生一个私密的数字，将这个私密的数字与客户端传来的数字相乘，得到乘积后发送给客户端
* 客户端也产生一个私密的数字然后和发送给服务器的数字相乘发送给服务器
* 服务器用自己的私密数字乘以客户端刚发来的数字得到的就是密钥
* 客户端用自己的私密数字乘以服务端发来的数字也得到了共同的密钥


### 中间人攻击
* 客户端请求服务器将自己的公钥返回给客户端，但在这个过程中被黑客所截获，黑客自己也生成一个非对称加密，将自己的公钥发给客户端，此时客户端只接受到了黑客所提供的公钥，而没有收到真正服务器的公钥
* 客户端生成随机字符串作为对称加密的秘钥，使用黑客的公钥加密并发送给了黑客，黑客解密字符串后再冒充客户端向服务器发送请求
* 黑客与服务器建立连接后，真正的客户端和服务器的通信就被黑客完全掌控。

### 身份伪造
黑客也可能冒充服务器和客户端进行通信，此时客户端并不知道对方是黑客还是真正的服务器。

### 签名 + 证书
* 服务器将自己的公钥、组织信息、个人信息提交给CA机构
* CA经过验证确保服务器的真实身份，如信息审核通过，CA会向申请者签发证书。
* 证书包含：申请者公钥、申请者的组织信息和个人信息、签发机构CA的信息、有效时间、证书序列号、签名hash算法等信息的明文，同时包含一个CA的签名;
签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名
* 客户端向服务器发起请求，服务器将自己的证书发送给客户端
* 客户端验证证书的相关信息；使用CA的公钥(一般CA的公钥都是内置在操作系统中的)对签名进行解密，得到摘要，在使用签名hash算法对明文进行hash运算得到一个摘要，两个摘要作对比，若一样说明证书是有效的，也就是服务器的身份是有效的
* 客户端产生随机字符串使用服务器的公钥加密并发送给服务器。
* 服务器使用私钥解密字符串，然后使用这个字符串将数据进行加密发送给客户端
* 客户端使用字符串解密服务器发来的数据
<img :src="$withBase('/images/net/v1/certification3.png')" alt="非对称加密" />




